% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parse_source.R, R/parse_sources.R
\name{parse_source}
\alias{parse_source}
\alias{print.rockParsedSource}
\alias{parse_sources}
\alias{print.rockParsedSources}
\alias{plot.rockParsedSources}
\title{Parsing sources}
\usage{
parse_source(x, codeRegexes = c(code =
  "\\\\[\\\\[([a-zA-Z0-9._>-]+)\\\\]\\\\]"), idRegexes = c(caseId =
  "\\\\[\\\\[cid=([a-zA-Z0-9._-]+)\\\\]\\\\]", stanzaId =
  "\\\\[\\\\[sid=([a-zA-Z0-9._-]+)\\\\]\\\\]"), sectionRegexes = c(paragraphs
  = "---paragraph-break---", secondary = "---<[a-zA-Z0-9]?>---"),
  autoGenerateIds = c("stanzaId"), persistentIds = c("caseId"),
  inductiveCodingHierarchyMarker = ">", delimiterRegEx = "^---$",
  ignoreRegex = "^#", ignoreOddDelimiters = FALSE, silent = FALSE)

\method{print}{rockParsedSource}(x, prefix = "### ", ...)

parse_sources(path, extension = "rock|dct", regex, codeRegexes = c(code =
  "\\\\[\\\\[([a-zA-Z0-9._>-]+)\\\\]\\\\]"), idRegexes = c(caseId =
  "\\\\[\\\\[cid=([a-zA-Z0-9._-]+)\\\\]\\\\]", stanzaId =
  "\\\\[\\\\[sid=([a-zA-Z0-9._-]+)\\\\]\\\\]"),
  autoGenerateIds = c("stanzaId"), sectionRegexes = c(paragraphs =
  "---paragraph-break---", secondary = "---<[a-zA-Z0-9]?>---"),
  inductiveCodingHierarchyMarker = ">", delimiterRegEx = "^---$",
  metadataContainers = c("metadata"), codesContainers = c("codes", "dct"),
  ignoreRegex = "^#", ignoreOddDelimiters = FALSE, encoding = "UTF-8",
  silent = TRUE)

\method{print}{rockParsedSources}(x, prefix = "### ", ...)

\method{plot}{rockParsedSources}(x, ...)
}
\arguments{
\item{x}{The character vector containing the source, for example as obtained through
\code{\link[base:readLines]{base::readLines()}}.}

\item{codeRegexes, idRegexes, sectionRegexes}{These are named character vectors with one
or more regular expressions. For \code{codeRegexes}, these specify how to extract the codes
(that were used to code the sources). For \code{idRegexes}, these specify how to extract the
different types of identifiers. For \code{sectionRegexes}, these specify how to extract the
different types of sections. The \code{codeRegexes} and \code{idRegexes} must each contain one
capturing group to capture the codes and identifiers, respectively.}

\item{autoGenerateIds}{The names of the \code{idRegexes} that, if missing, should receive
autogenerated identifiers (which consist of 'autogenerated_' followed by an incrementing
number).}

\item{persistentIds}{The names of the \code{idRegexes} for the identifiers which, once
attached to an utterance, should be attached to all following utterances as well (until
a new identifier with the same name is encountered, after which that identifier will be
attached to all following utterances, etc).}

\item{inductiveCodingHierarchyMarker}{For inductive coding, this marker is used to indicate
hierarchical relationships between codes. The code at the left hand side of this marker will
be considered the parent code of the code on the right hand side. More than two levels
can be specified in one code (for example, if the \code{inductiveCodingHierarchyMarker} is '>',
the code \code{grandparent>child>grandchild} would indicate codes at three levels.}

\item{delimiterRegEx}{The regular expression that is used to extract the YAML fragments.}

\item{ignoreRegex}{The regular expression that is used to delete lines before any other
processing. This can be used to enable adding comments to sources, which are then ignored
during analysis.}

\item{ignoreOddDelimiters}{If an odd number of YAML delimiters is encountered, whether this
should result in an error (\code{FALSE}) or just be silently ignored (\code{TRUE}).}

\item{silent}{Whether to provide (\code{FALSE}) or suppress (\code{TRUE}) more detailed progress updates.}
}
\description{
These function parse one (\code{parse_source}) or more (\code{parse_sources}) sources and the
contained identifiers, sections, and codes.
}
